---
title: 跟踪与非跟踪查询 - EF Core
description: 关于 Entity Framework Core 中跟踪与非跟踪查询的信息
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/tracking
ms.openlocfilehash: cb18125fb3453bb533981afb36480b12727cd6f2
ms.sourcegitcommit: 7700840119b1639275f3b64836e7abb59103f2e7
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/28/2021
ms.locfileid: "98983412"
---
# <a name="tracking-vs-no-tracking-queries"></a><span data-ttu-id="bb53c-103">跟踪与非跟踪查询</span><span class="sxs-lookup"><span data-stu-id="bb53c-103">Tracking vs. No-Tracking Queries</span></span>

<span data-ttu-id="bb53c-104">跟踪行为决定了 Entity Framework Core 是否将有关实体实例的信息保留在其更改跟踪器中。</span><span class="sxs-lookup"><span data-stu-id="bb53c-104">Tracking behavior controls if Entity Framework Core will keep information about an entity instance in its change tracker.</span></span> <span data-ttu-id="bb53c-105">如果已跟踪某个实体，则该实体中检测到的任何更改都会在 `SaveChanges()` 期间永久保存到数据库。</span><span class="sxs-lookup"><span data-stu-id="bb53c-105">If an entity is tracked, any changes detected in the entity will be persisted to the database during `SaveChanges()`.</span></span> <span data-ttu-id="bb53c-106">EF Core 还将修复跟踪查询结果中的实体与更改跟踪器中的实体之间的导航属性。</span><span class="sxs-lookup"><span data-stu-id="bb53c-106">EF Core will also fix up navigation properties between the entities in a tracking query result and the entities that are in the change tracker.</span></span>

> [!NOTE]
> <span data-ttu-id="bb53c-107">从不跟踪[无键实体类型](xref:core/modeling/keyless-entity-types)。</span><span class="sxs-lookup"><span data-stu-id="bb53c-107">[Keyless entity types](xref:core/modeling/keyless-entity-types) are never tracked.</span></span> <span data-ttu-id="bb53c-108">无论在何处提到实体类型，它都是指定义了键的实体类型。</span><span class="sxs-lookup"><span data-stu-id="bb53c-108">Wherever this article mentions entity types, it refers to entity types which have a key defined.</span></span>

> [!TIP]
> <span data-ttu-id="bb53c-109">可在 GitHub 上查看此文章的[示例](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking)。</span><span class="sxs-lookup"><span data-stu-id="bb53c-109">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking) on GitHub.</span></span>

## <a name="tracking-queries"></a><span data-ttu-id="bb53c-110">跟踪查询</span><span class="sxs-lookup"><span data-stu-id="bb53c-110">Tracking queries</span></span>

<span data-ttu-id="bb53c-111">默认情况下，跟踪返回实体类型的查询。</span><span class="sxs-lookup"><span data-stu-id="bb53c-111">By default, queries that return entity types are tracking.</span></span> <span data-ttu-id="bb53c-112">这表示可以更改这些实体实例，然后通过 `SaveChanges()` 持久化这些更改。</span><span class="sxs-lookup"><span data-stu-id="bb53c-112">Which means you can make changes to those entity instances and have those changes persisted by `SaveChanges()`.</span></span> <span data-ttu-id="bb53c-113">在以下示例中，将检测到对博客分级所做的更改，并在 `SaveChanges()` 期间将这些更改永久保存到数据库中。</span><span class="sxs-lookup"><span data-stu-id="bb53c-113">In the following example, the change to the blogs rating will be detected and persisted to the database during `SaveChanges()`.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#Tracking)]

<span data-ttu-id="bb53c-114">在跟踪查询中返回结果时，EF Core 将检查上下文中是否已存在实体。</span><span class="sxs-lookup"><span data-stu-id="bb53c-114">When the results are returned in a tracking query, EF Core will check if the entity is already in the context.</span></span> <span data-ttu-id="bb53c-115">如果 EF Core 找到现有的实体，则返回同样的实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-115">If EF Core finds an existing entity, then the same instance is returned.</span></span> <span data-ttu-id="bb53c-116">EF Core 不会用数据库值覆盖该实体中实体属性的当前值和原始值。</span><span class="sxs-lookup"><span data-stu-id="bb53c-116">EF Core won't overwrite current and original values of the entity's properties in the entry with the database values.</span></span> <span data-ttu-id="bb53c-117">如果未在上下文中找到该实体，EF Core 将创建新的实体实例，并将其附加到上下文。</span><span class="sxs-lookup"><span data-stu-id="bb53c-117">If the entity isn't found in the context, then EF Core will create a new entity instance and attach it to the context.</span></span> <span data-ttu-id="bb53c-118">查询结果不会包含任何已添加到上下文但尚未保存到数据库中的实体。</span><span class="sxs-lookup"><span data-stu-id="bb53c-118">Query results don't contain any entity, which is added to the context but not yet saved to the database.</span></span>

## <a name="no-tracking-queries"></a><span data-ttu-id="bb53c-119">非跟踪查询</span><span class="sxs-lookup"><span data-stu-id="bb53c-119">No-tracking queries</span></span>

<span data-ttu-id="bb53c-120">在只读方案中使用结果时，非跟踪查询十分有用。</span><span class="sxs-lookup"><span data-stu-id="bb53c-120">No tracking queries are useful when the results are used in a read-only scenario.</span></span> <span data-ttu-id="bb53c-121">可以更快速地执行非跟踪查询，因为无需设置更改跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="bb53c-121">They're quicker to execute because there's no need to set up the change tracking information.</span></span> <span data-ttu-id="bb53c-122">如果不需要更新从数据库中检索到的实体，则应使用非跟踪查询。</span><span class="sxs-lookup"><span data-stu-id="bb53c-122">If you don't need to update the entities retrieved from the database, then a no-tracking query should be used.</span></span> <span data-ttu-id="bb53c-123">可以将单个查询替换为非跟踪查询。</span><span class="sxs-lookup"><span data-stu-id="bb53c-123">You can swap an individual query to be no-tracking.</span></span> <span data-ttu-id="bb53c-124">非跟踪查询也会根据数据库中的内容提供结果，但不考虑本地更改或已添加的实体。</span><span class="sxs-lookup"><span data-stu-id="bb53c-124">No tracking query will also give you results based on what is in the database disregarding any local changes or added entities.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTracking)]

<span data-ttu-id="bb53c-125">还可以在上下文实例级别更改默认跟踪行为：</span><span class="sxs-lookup"><span data-stu-id="bb53c-125">You can also change the default tracking behavior at the context instance level:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ContextDefaultTrackingBehavior)]

## <a name="identity-resolution"></a><span data-ttu-id="bb53c-126">标识解析</span><span class="sxs-lookup"><span data-stu-id="bb53c-126">Identity resolution</span></span>

<span data-ttu-id="bb53c-127">由于跟踪查询使用更改跟踪器，因此 EF Core 将在跟踪查询中执行标识解析。</span><span class="sxs-lookup"><span data-stu-id="bb53c-127">Since a tracking query uses the change tracker, EF Core will do identity resolution in a tracking query.</span></span> <span data-ttu-id="bb53c-128">当具体化实体时，如果 EF Core 已被跟踪，则会从更改跟踪器返回相同的实体实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-128">When materializing an entity, EF Core will return the same entity instance from the change tracker if it's already being tracked.</span></span> <span data-ttu-id="bb53c-129">如果结果中多次包含相同的实体，则每次会返回相同的实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-129">If the result contains the same entity multiple times, you get back same instance for each occurrence.</span></span> <span data-ttu-id="bb53c-130">非跟踪查询不会使用更改跟踪器，也不会执行标识解析。</span><span class="sxs-lookup"><span data-stu-id="bb53c-130">No-tracking queries don't use the change tracker and don't do identity resolution.</span></span> <span data-ttu-id="bb53c-131">因此会返回实体的新实例，即使结果中多次包含相同的实体也是如此。</span><span class="sxs-lookup"><span data-stu-id="bb53c-131">So you get back a new instance of the entity even when the same entity is contained in the result multiple times.</span></span> <span data-ttu-id="bb53c-132">此行为与 EF Core 3.0 之前的版本中的行为有所不同，请参阅[早期版本](#previous-versions)。</span><span class="sxs-lookup"><span data-stu-id="bb53c-132">This behavior was different in versions before EF Core 3.0, see [previous versions](#previous-versions).</span></span>

<span data-ttu-id="bb53c-133">从 EF Core 5.0 开始，可以在同一个查询中结合使用上述两种行为。</span><span class="sxs-lookup"><span data-stu-id="bb53c-133">Starting with EF Core 5.0, you can combine both of the above behaviors in same query.</span></span> <span data-ttu-id="bb53c-134">也就是说，可以使用非跟踪查询并对结果执行标识解析。</span><span class="sxs-lookup"><span data-stu-id="bb53c-134">That is, you can have a no tracking query, which will do identity resolution in the results.</span></span> <span data-ttu-id="bb53c-135">我们添加了另一个运算符 `AsNoTrackingWithIdentityResolution()`，就像添加 `AsNoTracking()` 可查询运算符一样。</span><span class="sxs-lookup"><span data-stu-id="bb53c-135">Just like `AsNoTracking()` queryable operator, we've added another operator `AsNoTrackingWithIdentityResolution()`.</span></span> <span data-ttu-id="bb53c-136"><xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> 枚举中也添加了一个关联项。</span><span class="sxs-lookup"><span data-stu-id="bb53c-136">There's also associated entry added in the <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> enum.</span></span> <span data-ttu-id="bb53c-137">如果将查询配置为使用标识解析和非跟踪行为，生成查询结果时我们将在后台使用独立的更改追踪器，以便仅将每个实例具体化一次。</span><span class="sxs-lookup"><span data-stu-id="bb53c-137">When you configure the query to use identity resolution with no tracking, we use a stand-alone change tracker in the background when generating query results so each instance is materialized only once.</span></span> <span data-ttu-id="bb53c-138">此更改追踪器不同于上下文中的更改追踪器，因此上下文不会追踪这些结果。</span><span class="sxs-lookup"><span data-stu-id="bb53c-138">Since this change tracker is different from the one in the context, the results are not tracked by the context.</span></span> <span data-ttu-id="bb53c-139">完全枚举查询后，该更改追踪器将超出范围，并根据需要对其进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="bb53c-139">After the query is enumerated fully, the change tracker goes out of scope and garbage collected as required.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTrackingWithIdentityResolution)]

## <a name="tracking-and-custom-projections"></a><span data-ttu-id="bb53c-140">跟踪和自定义投影</span><span class="sxs-lookup"><span data-stu-id="bb53c-140">Tracking and custom projections</span></span>

<span data-ttu-id="bb53c-141">即使查询的结果类型不是实体类型，默认情况下 EF Core 也会跟踪结果中包含的实体类型。</span><span class="sxs-lookup"><span data-stu-id="bb53c-141">Even if the result type of the query isn't an entity type, EF Core will still track entity types contained in the result by default.</span></span> <span data-ttu-id="bb53c-142">在以下返回匿名类型的查询中，会跟踪结果集中 `Blog` 的实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-142">In the following query, which returns an anonymous type, the instances of `Blog` in the result set will be tracked.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection1)]

<span data-ttu-id="bb53c-143">如果结果集包含来自 LINQ 组合的实体类型，EF Core 将跟踪它们。</span><span class="sxs-lookup"><span data-stu-id="bb53c-143">If the result set contains entity types coming out from LINQ composition, EF Core will track them.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

<span data-ttu-id="bb53c-144">如果结果集不包含任何实体类型，则不会执行跟踪。</span><span class="sxs-lookup"><span data-stu-id="bb53c-144">If the result set doesn't contain any entity types, then no tracking is done.</span></span> <span data-ttu-id="bb53c-145">在以下查询中，我们返回匿名类型（具有实体中的某些值，但没有实际实体类型的实例）。</span><span class="sxs-lookup"><span data-stu-id="bb53c-145">In the following query, we return an anonymous type with some of the values from the entity (but no instances of the actual entity type).</span></span> <span data-ttu-id="bb53c-146">查询中没有任何被跟踪的实体。</span><span class="sxs-lookup"><span data-stu-id="bb53c-146">There are no tracked entities coming out of the query.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection3)]

 <span data-ttu-id="bb53c-147">EF Core 支持执行顶级投影中的客户端评估。</span><span class="sxs-lookup"><span data-stu-id="bb53c-147">EF Core supports doing client evaluation in the top-level projection.</span></span> <span data-ttu-id="bb53c-148">如果 EF Core 具体化实体实例以进行客户端评估，则会跟踪该实体实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-148">If EF Core materializes an entity instance for client evaluation, it will be tracked.</span></span> <span data-ttu-id="bb53c-149">此处，由于我们要将 `blog` 实体传递到客户端方法 `StandardizeURL`，因此 EF Core 也会跟踪博客实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-149">Here, since we're passing `blog` entities to the client method `StandardizeURL`, EF Core will track the blog instances too.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientMethod)]

<span data-ttu-id="bb53c-150">EF Core 不会跟踪结果中包含的无键实体实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-150">EF Core doesn't track the keyless entity instances contained in the result.</span></span> <span data-ttu-id="bb53c-151">但 EF Core 会根据上述规则跟踪带有键的实体类型的所有其他实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-151">But EF Core tracks all the other instances of entity types with a key according to rules above.</span></span>

<span data-ttu-id="bb53c-152">在 EF Core 3.0 之前，某些上述规则的工作方式有所不同。</span><span class="sxs-lookup"><span data-stu-id="bb53c-152">Some of the above rules worked differently before EF Core 3.0.</span></span> <span data-ttu-id="bb53c-153">有关详细信息，请参阅[早期版本](#previous-versions)。</span><span class="sxs-lookup"><span data-stu-id="bb53c-153">For more information, see [previous versions](#previous-versions).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="bb53c-154">旧版</span><span class="sxs-lookup"><span data-stu-id="bb53c-154">Previous versions</span></span>

<span data-ttu-id="bb53c-155">在 3.0 版之前，EF Core 执行跟踪的方式有一些差异。</span><span class="sxs-lookup"><span data-stu-id="bb53c-155">Before version 3.0, EF Core had some differences in how tracking was done.</span></span> <span data-ttu-id="bb53c-156">显著的差异如下：</span><span class="sxs-lookup"><span data-stu-id="bb53c-156">Notable differences are as follows:</span></span>

- <span data-ttu-id="bb53c-157">如[客户端与服务器评估](xref:core/querying/client-eval)页中所述，在 3.0 版之前，EF Core 支持在查询的任何部分中执行客户端评估。</span><span class="sxs-lookup"><span data-stu-id="bb53c-157">As explained in the [Client vs Server Evaluation](xref:core/querying/client-eval) page, EF Core supported client evaluation in any part of the query before version 3.0.</span></span> <span data-ttu-id="bb53c-158">客户端评估导致了实体的具体化，这不是结果的一部分。</span><span class="sxs-lookup"><span data-stu-id="bb53c-158">Client evaluation caused materialization of entities, which weren't part of the result.</span></span> <span data-ttu-id="bb53c-159">因此 EF Core 分析了结果以检测要跟踪的内容。此设计有一些不同之处，如下所示：</span><span class="sxs-lookup"><span data-stu-id="bb53c-159">So EF Core analyzed the result to detect what to track. This design had certain differences as follows:</span></span>
  - <span data-ttu-id="bb53c-160">投影中的客户端评估（导致具体化，但未返回具体化的实体实例）未被跟踪。</span><span class="sxs-lookup"><span data-stu-id="bb53c-160">Client evaluation in the projection, which caused materialization but didn't return the materialized entity instance wasn't tracked.</span></span> <span data-ttu-id="bb53c-161">以下示例未跟踪 `blog` 实体。</span><span class="sxs-lookup"><span data-stu-id="bb53c-161">The following example didn't track `blog` entities.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

  - <span data-ttu-id="bb53c-162">在某些情况下，EF Core 未跟踪来自 LINQ 组合的对象。</span><span class="sxs-lookup"><span data-stu-id="bb53c-162">EF Core didn't track the objects coming out of LINQ composition in certain cases.</span></span> <span data-ttu-id="bb53c-163">以下示例未跟踪 `Post`。</span><span class="sxs-lookup"><span data-stu-id="bb53c-163">The following example didn't track `Post`.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

- <span data-ttu-id="bb53c-164">只要查询结果中包含无键实体类型，整个查询就会进行非跟踪。</span><span class="sxs-lookup"><span data-stu-id="bb53c-164">Whenever query results contained keyless entity types, the whole query was made non-tracking.</span></span> <span data-ttu-id="bb53c-165">这表示不会跟踪结果中包含的带有键的实体类型。</span><span class="sxs-lookup"><span data-stu-id="bb53c-165">That means that entity types with keys, which are in the result weren't being tracked either.</span></span>
- <span data-ttu-id="bb53c-166">EF Core 曾经在非跟踪查询中执行标识解析。</span><span class="sxs-lookup"><span data-stu-id="bb53c-166">EF Core used to do identity resolution in no-tracking queries.</span></span> <span data-ttu-id="bb53c-167">它使用了弱引用来跟踪已返回的实体。</span><span class="sxs-lookup"><span data-stu-id="bb53c-167">It used weak references to keep track of entities that had already been returned.</span></span> <span data-ttu-id="bb53c-168">因此，如果结果集多次包含相同的实体，则每次会返回相同的实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-168">So if a result set contained the same entity multiples times, you would get the same instance for each occurrence.</span></span> <span data-ttu-id="bb53c-169">尽管具有相同标识的上一个结果超出了范围并进行了垃圾回收，EF Core 也会返回新实例。</span><span class="sxs-lookup"><span data-stu-id="bb53c-169">Though if a previous result with the same identity went out of scope and got garbage collected, EF Core returned a new instance.</span></span>
